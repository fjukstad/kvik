package gopencpu

import (
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
)

type GoOpenCPU struct {
	Addr     string
	Username string
	Password string
}

// Initializes gopencpu instance located at addr using the username/password
// combination.
func NewGoOpenCPU(addr, username, password string) *GoOpenCPU {
	opencpu := new(GoOpenCPU)
	opencpu.Addr = "http://" + addr
	opencpu.Username = username
	opencpu.Password = password
	return opencpu
}

// Executes a plotting function, downloads the plot and stores it with the
// given filename
func (g *GoOpenCPU) Plot(fun, args, filetype, filename string) error {
	s, err := g.Call(fun, args)
	if err != nil {
		return err
	}

	return s.DownloadPlot(filetype, filename)
}

// Downloads a plot from a running session and stores it with the given filename
func (s *Session) DownloadPlot(filetype, filename string) error {
	url := s.Graphics + "/" + filetype
	resp, err := http.Get(url)

	if err != nil {
		return nil
	}

	if resp.StatusCode != 200 {
		return errors.New(resp.Status)
	}

	plot, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	err = ioutil.WriteFile(filename, plot, 0644)
	if err != nil {
		return err
	}

	return nil
}

// Execcutes the command and returns the results formatted in the specified
// format e.g. json or csv
func (g *GoOpenCPU) Rpc(fun, args, format string) (string, error) {

	//	fmt.Println("-H \"Content-Type: application/json\" -d '", args, "'")

	s, err := g.Call(fun, args)

	if err != nil {
		s, err = g.Call(fun, args)
		if err != nil {
			fmt.Println("failed a second time...", err)
			return "", err
		}

	}

	//	time.Sleep(100 * time.Millisecond)

	res, err := s.GetResult(g, format)
	if err != nil {
		res, err = s.GetResult(g, format)
		fmt.Println("Get result error second time ")
	}
	return res, err
}

// Executes the functions with the given arguments. Returns as session which can
// be used to get the output and plots etc. from.
func (g *GoOpenCPU) Call(fun, args string) (s *Session, err error) {

	url := g.getUrl(fun)
	postArgs := strings.NewReader(args)

	fmt.Println(url, postArgs)

	client := &http.Client{}
	req, err := http.NewRequest("POST", url, postArgs)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	var contentType string
	if strings.Contains(args, "{") {
		contentType = "application/json"
	} else {
		contentType = "application/x-www-form-urlencoded"
	}

	header := map[string][]string{
		"Content-Type": {contentType},
	}

	req.Header = header
	req.SetBasicAuth(g.Username, g.Password)

	defer req.Body.Close()

	var resp *http.Response
	resp, err = client.Do(req)

	//resp, err := http.Post(url, "application/json", postArgs)
	if err != nil {
		fmt.Println("call failed", err)
		return nil, err
	}

	fmt.Println("OpenCPU cache", resp.Header.Get("X-ocpu-cache"))
	//defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("empty body")
		return nil, err
	}

	if resp.StatusCode != 201 {
		fmt.Println("Statuscode != 201")
		return nil, errors.New(string(body))
	}

	s = new(Session)

	s.Key = resp.Header.Get("X-Ocpu-Session")
	s.Url = resp.Header.Get("Location")

	output := strings.Split(string(body), "\n")
	for _, line := range output {
		switch {
		case strings.Contains(line, ".val"):
			s.val = g.Addr + line
		case strings.Contains(line, "stdout"):
			s.stdout = g.Addr + line
		case strings.Contains(line, "source"):
			s.source = g.Addr + line
		case strings.Contains(line, "info"):
			s.info = g.Addr + line
		case strings.Contains(line, "DESCRIPTION"):
			s.description = g.Addr + line
		case strings.Contains(line, "console"):
			s.console = g.Addr + line
		case strings.Contains(line, "graphics"):
			s.Graphics = g.Addr + line
		}
	}

	return s, nil

}

func (g *GoOpenCPU) getUrl(fun string) string {
	if strings.Contains(fun, "github.com") {
		fun = strings.TrimLeft(fun, "github.com/")
		return g.Addr + "/ocpu/github/" + fun
	}
	return g.Addr + "/ocpu/library/" + fun
}

// Returns any output files that was generated by the session with the given
// key. Examples of filetypes are pdf, csv, png.
func (g *GoOpenCPU) Get(key, filetype string) ([]byte, error) {
	var url string
	if strings.Contains(filetype, "png") || strings.Contains(filetype, "pdf") {
		url = g.Addr + "/ocpu/tmp/" + key + "/graphics/last/" + filetype
	} else {
		url = g.Addr + "/ocpu/tmp/" + key + "/R/.val/" + filetype
	}

	client := &http.Client{}
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		fmt.Println("Culd not create request", err)
		return nil, err
	}

	req.SetBasicAuth(g.Username, g.Password)

	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("Could not get", err)
		return nil, err
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("Could not read from body", err)
	}

	return body, err
}

// The OpenCPU session. Read more about it at
// https://www.opencpu.org/api.html#api-session
type Session struct {
	Key         string
	Url         string
	Result      string
	console     string
	stdout      string
	val         string
	info        string
	description string
	Graphics    string
	source      string
}

// Get url for OpenCPU session. Format is fileformat, e.g. json
func (s *Session) GetUrl(format string) (url string) {
	return s.val + "/" + format
}

// Fetches the result from a Session in the given format.
func (s *Session) GetResult(g *GoOpenCPU, format string) (string, error) {
	url := s.GetUrl(format)

	client := &http.Client{}
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		fmt.Println(err)
		req, err = http.NewRequest("GET", url, nil)
		if err != nil {
			fmt.Println("failed second time")
			return "", err
		}
	}
	header := map[string][]string{
		"Content-Type": {"application/json"},
	}

	req.Header = header
	req.SetBasicAuth(g.Username, g.Password)

	resp, err := client.Do(req)

	if err != nil {
		fmt.Println("Client did not")
		return "", err
	}

	if resp.StatusCode != 200 {
		error, _ := ioutil.ReadAll(resp.Body)
		errorText := string(error)
		fmt.Println("Status code not 200 in GetResult", string(error))
		resp, err = client.Do(req)
		if err != nil && resp.StatusCode != 200 {
			fmt.Println("status code second time jesus christ")
			return "", errors.New(errorText)
		}

	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("bodu thing wrong", err)
		return "", nil
	}

	s.Result = string(body)

	return s.Result, nil
}
